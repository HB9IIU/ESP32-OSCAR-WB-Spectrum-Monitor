#include <WiFi.h>
#include <WebSocketsClient.h>
#include <Arduino.h>
#include <TFT_eSPI.h>      // Include the TFT_eSPI library
TFT_eSPI tft = TFT_eSPI(); // Initialize the TFT display

const char *ssid = "NO WIFI FOR YOU!!!";
const char *password = "Nestle2010Nestle";
const char *websocketServer = "185.83.169.27"; // IP of the server
const int websocketPort = 443;                 // Port for WSS

#define MAX_X_COORDS 480 // Maximum x-coordinates based on display width

WebSocketsClient webSocket;

uint16_t previousYCoords[MAX_X_COORDS]; // Array to store the previous y-coordinates

// Spectrum parameters
const float START_FREQ = 10490.0; // MHz
const float BANDWIDTH = 9.0;      // MHz
// for gradient calculation
int yTopBeacon = 320;
// Function to map x-coordinate to frequency
float mapXToFrequency(int x, float startFreq, float bandwidth)
{
  return startFreq + (bandwidth * x / MAX_X_COORDS);
}

// Function to map frequency to x-coordinate
int mapFrequencyToX(float frequency, float startFreq, float bandwidth)
{
  return (frequency - startFreq) * MAX_X_COORDS / bandwidth;
}

// Function to map fftValue to a color gradient (dark green to red)
uint16_t mapValueToColor1(uint16_t value)
{
  int topSection = 60;                                              // higher the value, lower the upper margin
  uint8_t red = map(value, 320, yTopBeacon - topSection, 255, 255); // Keep red at 255
  uint8_t green = map(value, 320, yTopBeacon - topSection, 0, 255); // Increase green to create yellow

  return tft.color565(red, green, 0); // Convert RGB to 16-bit color
}
uint16_t mapValueToColor2(uint16_t value)
{
  int topSection = 0;                                               // higher the value, lower the upper margin
  uint8_t red = map(value, 320, yTopBeacon - topSection, 0, 255);   // Keep red at 255
  uint8_t green = map(value, 320, yTopBeacon - topSection, 0, 255); // Increase green to create yellow

  return tft.color565(red, green, 0); // Convert RGB to 16-bit color
}

uint16_t mapValueToColor(uint16_t value)
{
  int topGreen = 90;                                              // higher the value, lower the upper margin
  uint8_t red = map(value, 320, yTopBeacon - topGreen, 255, 0);   // Increase red with value
  uint8_t green = map(value, 320, yTopBeacon - topGreen, 0, 255); // Decrease green with value
  // uint8_t blue = map(value, 320, yTopBeacon - topGreen, 0, 255);  // Decrease green with value

  return tft.color565(red, green, 0); // Convert RGB to 16-bit color
}

// Function to handle FFT data and update the display
void handleFFTData(uint8_t *payload, size_t length, uint16_t bgColor = TFT_BLACK)
{
  static bool isFirstRun = true;

  if (isFirstRun)
  {
    for (int i = 0; i < MAX_X_COORDS; i++)
    {
      previousYCoords[i] = 320; // Initialize all to the bottom of the display
    }
    isFirstRun = false;
  }

  size_t xCoord = 0; // Initialize x-coordinate

  for (size_t i = 0; i < length && xCoord < MAX_X_COORDS; i += 4) // Increment by 4 for every second value
  {
    uint16_t fftValue = payload[i] | (payload[i + 1] << 8); // Combine two bytes
    uint16_t yCoord = 320 - ((fftValue - 8000) / 140);      // Scale for TFT display

    // Clamp yCoord to screen bounds
    yCoord = constrain(yCoord, 0, 320);

    // Erase the previous vertical line if needed
    if (previousYCoords[xCoord] != yCoord)
    {
      tft.drawLine(xCoord + 10, 320, xCoord + 10, previousYCoords[xCoord], bgColor);
    }

    // Draw the gradient dots
    for (int y = 320; y > yCoord; y -= 1) // Create the dots effect
    {
      uint16_t dotColor = mapValueToColor(y); // Adjust color for height
      tft.drawPixel(xCoord + 10, y, dotColor);
    }

    // Update the previous Y-coordinate
    previousYCoords[xCoord] = yCoord;

    if (yCoord < yTopBeacon && xCoord < 312)
    {
      yTopBeacon = yCoord;
    }

    xCoord++; // Move to the next x-coordinate
  }
  // float targetFreq = 10492.3;
  // int xCo = mapFrequencyToX(targetFreq, START_FREQ, BANDWIDTH);
  // Serial.printf("Frequency %.2f MHz corresponds to x-coordinate %d\n", targetFreq, xCo);
  // Serial.println(yTopBeacon);
  // delay(2000);
  // yTopBeacon=0;
}

// Function to handle WebSocket events
void webSocketEvent(WStype_t type, uint8_t *payload, size_t length)
{
  switch (type)
  {
  case WStype_BIN:
    handleFFTData(payload, length);
    break;
  case WStype_DISCONNECTED:
    Serial.println("WebSocket Disconnected");
    break;
  case WStype_CONNECTED:
    Serial.println("WebSocket Connected");
    webSocket.sendTXT("Hello, ESP32 here!");
    break;
  default:
    break;
  }
}

void setup()
{
  Serial.begin(115200);

  // Initialize the TFT display
  pinMode(TFT_BLP, OUTPUT);
  digitalWrite(TFT_BLP, HIGH); // Turn on the backlight

  tft.begin();               // Initialize the TFT
  tft.fillScreen(TFT_BLACK); // Set background to black
  tft.setRotation(1);        // Set rotation if needed
  tft.println("Starting FFT Display");

  // Connect to WiFi
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED)
  {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("WiFi Connected!");

  // Connect to WebSocket server
  webSocket.beginSSL(websocketServer, websocketPort, "/wb/fft", "", ""); // Skip certificate validation
  webSocket.onEvent(webSocketEvent);
}

void loop()
{
  webSocket.loop(); // Maintain WebSocket connection
}
